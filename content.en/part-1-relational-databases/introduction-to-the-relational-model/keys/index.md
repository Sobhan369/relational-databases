---
title:  Keys
weight: 3
references:
    videos:
        - youtube:Ip1RhEyL7zM
        - youtube:_UZLrD_R0T4
    links:
        - https://www.geeksforgeeks.org/types-of-keys-in-relational-model-candidate-super-primary-alternate-and-foreign/
        - https://www.javatpoint.com/dbms-keys
    books:
        - b1:
            title: Database Management System
            url: https://www.google.co.in/books/edition/krishna_s_Database_Management_System/YM0AvJp6ocUC?hl=en&gbpv=1&dq=keys+in+dbms+books&printsec=frontcover
        - b2:
            title: Database Systems
            url: https://www.google.co.in/books/edition/Database_Systems_The_Complete_Book/-5mqs4hQIBcC?hl=en&gbpv=1&dq=keys+in+dbms+books&printsec=frontcover
---
# Keys

We must have a way to specify how tuples within a given relation are distin- guished. This is expressed in terms of their attributes. That is, the values of the attribute values of a tuple must be such that they can _uniquely identify_ the tuple. In other words, no two tuples in a relation are allowed to have exactly the same value for all attributes.

A **superkey** is a set of one or more attributes that, taken collectively, allow us to identify uniquely a tuple in the relation. For example, the _ID_ attribute of the relation _instructor_ is sufficient to distinguish one instructor tuple from another. Thus, _ID_ is a superkey. The _name_ attribute of _instructor_, on the other hand, is not a superkey, because several instructors might have the same name.

Formally, let _R_ denote the set of attributes in the schema of relation _r_ . If we say that a subset _K_ of _R_ is a _superkey_ for _r_ , we are restricting consideration to instances of relations _r_ in which no two distinct tuples have the same values on all attributes in _K_. That is, if _t_~1~ and _t_~2~ are in _r_ and _t_~1~ ≠= _t_~2~ , then _t_~1~_.K_ ≠= _t_~2~ _.K_ .

A superkey may contain extraneous attributes. For example, the combination of _ID_ and _name_ is a superkey for the relation _instructor_. If _K_ is a superkey, then so is any superset of _K_. We are often interested in superkeys for which no proper subset is a superkey. Such minimal superkeys are called **candidate keys**.

It is possible that several distinct sets of attributes could serve as a candidate key. Suppose that a combination of _name_ and _dept name_ is sufficient to distinguish among members of the _instructor_ relation. Then, both _{ID}_ and _{name_, _dept name}_ are candidate keys. Although the attributes _ID_ and _name_ together can distinguish _instructor_ tuples, their combination, _{ID_, _name}_, does not form a candidate key, since the attribute _ID_ alone is a candidate key.

We shall use the term **primary key** to denote a candidate key that is chosen by the database designer as the principal means of identifying tuples within a relation. A key (whether primary, candidate, or super) is a property of the entire relation, rather than of the individual tuples. Any two individual tuples in the relation are prohibited from having the same value on the key attributes at the same time. The designation of a key represents a constraint in the real-world enterprise being modeled.

Primary keys must be chosen with care. As we noted, the name of a person is obviously not sufficient, because there may be many people with the same name. In the United States, the social-security number attribute of a person would be a candidate key. Since non-U.S. residents usually do not have social-security numbers, international enterprises must generate their own unique identifiers. An alternative is to use some unique combination of other attributes as a key.

The primary key should be chosen such that its attribute values are never, or very rarely, changed. For instance, the address field of a person should not be part of the primary key, since it is likely to change. Social-security numbers, on the other hand, are guaranteed never to change. Unique identifiers generated by enterprises generally do not change, except if two enterprises merge; in such a case the same identifier may have been issued by both enterprises, and a reallocation of identifiers may be required to make sure they are unique.

It is customary to list the primary key attributes of a relation schema before the other attributes; for example, the _dept name_ attribute of _department_ is listed first, since it is the primary key. Primary key attributes are also underlined.

A relation, say _r_~1~, may include among its attributes the primary key of another relation, say _r_~2~\. This attribute is called a **foreign key** from _r_~1~, referencing _r_~2~\. The relation _r_~1~ is also called the **referencing relation** of the foreign key dependency, and _r_~2~ is called the **referenced relation** of the foreign key. For example, the attribute _dept name_ in _instructor_ is a foreign key from _instructor_, referencing _department_, since _dept name_ is the primary key of _department_. In any database instance, given any tuple, say _t~a~_ , from the _instructor_ relation, there must be some tuple, say _t~b~_ , in the _department_ relation such that the value of the _dept name_ attribute of _t~a~_ is the same as the value of the primary key, _dept name_, of _t~b~_ .

Now consider the _section_ and _teaches_ relations. It would be reasonable to require that if a section exists for a course, it must be taught by at least one instructor; however, it could possibly be taught by more than one instructor. To enforce this constraint, we would require that if a particular (_course id_, _sec id_, _semester_, _year_) combination appears in _section_, then the same combination must appear in _teaches_. However, this set of values does not form a primary key for _teaches_, since more than one instructor may teach one such section. As a result, we cannot declare a foreign key constraint from _section_ to _teaches_ (although we can define a foreign key constraint in the other direction, from _teaches_ to _section_).

The constraint from _section_ to _teaches_ is an example of a **referential integrity constraint**; a referential integrity constraint requires that the values appearing in specified attributes of any tuple in the referencing relation also appear in specified attributes of at least one tuple in the referenced relation.
